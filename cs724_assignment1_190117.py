# -*- coding: utf-8 -*-
"""CS724-Assignment1-190117.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1-puNnooNQc1vtOhvUD1JhyofosEQhfn_

# CS724 Assignment 1 (190117)

# Question 1

**1) $$ A = \begin{bmatrix}
    1 & 0\\ 
    0 & 1
  \end{bmatrix} $$**

  $$ C(A) = R^2 $$ 

**2) $$ B = \begin{bmatrix}
    1 & 2\\ 
    2 & 4
  \end{bmatrix} $$**

  $$ C(B) = R^1 $$ 

**3) $$ D = \begin{bmatrix}
    1 & 2 & 3\\ 
    0 & 0 & 4
  \end{bmatrix} $$**

  $$ C(D) = R^2 $$

# Question 2

Let the coordinate units be Km;

User Position U: (100, 100, 100)

Let's fix the 5 satellites at the following positions:

S1: (100000, 100000, 100000)

S2: (-200000, 300000, -500000)

S3: (400000, 700000, -1000000)

S4: (1000000, -200000, 1000000)

S5: (10000000, -10000000, -10000000)
"""

import numpy as np
import random
import matplotlib.pyplot as plt

# coordinate units: Km
user = np.array([100, 100, 100])
# speed unit: Km/s
speed = 300000 

s0 = np.array([100000, 100000, 100000])
s1 = np.array([-200000, 300000, -500000])
s2 = np.array([400000, 700000, -1000000])
s3 = np.array([1000000, -200000, 1000000])
s4 = np.array([10000000, -10000000, -10000000])

s = np.array([s0, s1, s2, s3, s4])
s

"""# (a) Time taken for a signal to arrive from each one of these satellites to the user:

"""

# time taken = distance/speed

t0 = np.linalg.norm(s0-user)/speed
t1 = np.linalg.norm(s1-user)/speed
t2 = np.linalg.norm(s2-user)/speed
t3 = np.linalg.norm(s3-user)/speed
t4 = np.linalg.norm(s4-user)/speed

T = np.array([t0, t1, t2, t3, t4])
T
# In seconds

"""# (b) Location of the user using the satellite locations and the times:

For GPS Localization, 

$$ Ax = B $$

$$ \implies \hat{x} = (A^T A)^{-1} A^T B $$

where A and B are calculated as follows:
"""

R = np.multiply(300000, T)
R

#A
A0 = np.array([np.append(2*(s1-s0),2*(R[1]-R[0])), np.append(2*(s2-s1),2*(R[2]-R[1])), np.append(2*(s3-s2),2*(R[3]-R[2])), np.append(2*(s4-s3),2*(R[4]-R[3]))])
A0

#B
B0 = np.array([(R[0]**2 - R[1]**2) - (np.linalg.norm(s0)**2 - np.linalg.norm(s1)**2), (R[1]**2 - R[2]**2) - (np.linalg.norm(s1)**2 - np.linalg.norm(s2)**2), (R[2]**2 - R[3]**2) - (np.linalg.norm(s2)**2 - np.linalg.norm(s3)**2), (R[3]**2 - R[4]**2) - (np.linalg.norm(s3)**2 - np.linalg.norm(s4)**2)])
B0

# x_hat
x = np.matmul(np.matmul(np.linalg.inv(np.matmul(A0.transpose(),A0)),A0.transpose()),B0)
x
# We got U = (100,100,100) as expected

"""# (c) Adding some random errors with the times:

Even for a 1 second time difference, the error in position can be more than 300000 Km. Hence we will start with very less time error.
"""

# Adding 0.0033% error in time
T_random = np.array([t0+random.randrange(-19,19)/1000000, t1+random.randrange(-69,69)/1000000, t2+random.randrange(-143,143)/1000000, t3+random.randrange(-159,159)/1000000, t4+random.randrange(-1924,1924)/1000000])
R = np.multiply(300000, T_random)
A = np.array([np.append(2*(s1-s0),2*(R[1]-R[0])), np.append(2*(s2-s1),2*(R[2]-R[1])), np.append(2*(s3-s2),2*(R[3]-R[2])), np.append(2*(s4-s3),2*(R[4]-R[3]))])
B = np.array([(R[0]**2 - R[1]**2) - (np.linalg.norm(s0)**2 - np.linalg.norm(s1)**2), (R[1]**2 - R[2]**2) - (np.linalg.norm(s1)**2 - np.linalg.norm(s2)**2), (R[2]**2 - R[3]**2) - (np.linalg.norm(s2)**2 - np.linalg.norm(s3)**2), (R[3]**2 - R[4]**2) - (np.linalg.norm(s3)**2 - np.linalg.norm(s4)**2)])
x_hat = np.matmul(np.matmul(np.linalg.inv(np.matmul(A.transpose(),A)),A.transpose()),B)
print("User Position:", x_hat) # first 3 elements are its coordinates
print("Distance from actual position of user:", np.linalg.norm(x_hat - np.array([100,100,100,x_hat[3]])))
# We see 100s of Kms of position error

"""# (d) Increasing Time errors:

Taking time errors 0.0033%, 0.033%, 0.1%, 0.33%, 1% and taking average of User Position and Error in Position to plot a curve for the same:
"""

# Error in Time = 0.0033%
sum = np.array([0,0,0,0])
error1 = 0
for i in range(0,10):
  T_random = np.array([t0+random.randrange(-19,19)/1000000, t1+random.randrange(-69,69)/1000000, t2+random.randrange(-143,143)/1000000, t3+random.randrange(-159,159)/1000000, t4+random.randrange(-1924,1924)/1000000])
  R = np.multiply(300000, T_random)
  A = np.array([np.append(2*(s1-s0),2*(R[1]-R[0])), np.append(2*(s2-s1),2*(R[2]-R[1])), np.append(2*(s3-s2),2*(R[3]-R[2])), np.append(2*(s4-s3),2*(R[4]-R[3]))])
  B = np.array([(R[0]**2 - R[1]**2) - (np.linalg.norm(s0)**2 - np.linalg.norm(s1)**2), (R[1]**2 - R[2]**2) - (np.linalg.norm(s1)**2 - np.linalg.norm(s2)**2), (R[2]**2 - R[3]**2) - (np.linalg.norm(s2)**2 - np.linalg.norm(s3)**2), (R[3]**2 - R[4]**2) - (np.linalg.norm(s3)**2 - np.linalg.norm(s4)**2)])
  x_hat = np.matmul(np.matmul(np.linalg.inv(np.matmul(A.transpose(),A)),A.transpose()),B)
  error_x = np.linalg.norm(x_hat - np.array([100,100,100,x_hat[3]]))
  error1 = error1 + error_x
  sum = sum + x_hat

print("Average User Position:", sum/10) # first 3 elements are its coordinates
print("Average Error in Position:", error1/10)

# Error in Time = 0.033%
sum = np.array([0,0,0,0])
error2 = 0
for i in range(0,10):
  T_random = np.array([t0+random.randrange(-19,19)/100000, t1+random.randrange(-69,69)/100000, t2+random.randrange(-143,143)/100000, t3+random.randrange(-159,159)/100000, t4+random.randrange(-1924,1924)/100000])
  R = np.multiply(300000, T_random)
  A = np.array([np.append(2*(s1-s0),2*(R[1]-R[0])), np.append(2*(s2-s1),2*(R[2]-R[1])), np.append(2*(s3-s2),2*(R[3]-R[2])), np.append(2*(s4-s3),2*(R[4]-R[3]))])
  B = np.array([(R[0]**2 - R[1]**2) - (np.linalg.norm(s0)**2 - np.linalg.norm(s1)**2), (R[1]**2 - R[2]**2) - (np.linalg.norm(s1)**2 - np.linalg.norm(s2)**2), (R[2]**2 - R[3]**2) - (np.linalg.norm(s2)**2 - np.linalg.norm(s3)**2), (R[3]**2 - R[4]**2) - (np.linalg.norm(s3)**2 - np.linalg.norm(s4)**2)])
  x_hat = np.matmul(np.matmul(np.linalg.inv(np.matmul(A.transpose(),A)),A.transpose()),B)
  error_x = np.linalg.norm(x_hat - np.array([100,100,100,x_hat[3]]))
  error2 = error2 + error_x
  sum = sum + x_hat

print("Average User Position:", sum/10) # first 3 elements are its coordinates
print("Average Error in Position:", error2/10)

# Error in Time = 0.1%
sum = np.array([0,0,0,0])
error3 = 0
for i in range(0,10):
  T_random = np.array([t0+random.randrange(-58,58)/100000, t1+random.randrange(-206,206)/100000, t2+random.randrange(-428,428)/100000, t3+random.randrange(-476,476)/100000, t4+random.randrange(-5774,5774)/100000])
  R = np.multiply(300000, T_random)
  A = np.array([np.append(2*(s1-s0),2*(R[1]-R[0])), np.append(2*(s2-s1),2*(R[2]-R[1])), np.append(2*(s3-s2),2*(R[3]-R[2])), np.append(2*(s4-s3),2*(R[4]-R[3]))])
  B = np.array([(R[0]**2 - R[1]**2) - (np.linalg.norm(s0)**2 - np.linalg.norm(s1)**2), (R[1]**2 - R[2]**2) - (np.linalg.norm(s1)**2 - np.linalg.norm(s2)**2), (R[2]**2 - R[3]**2) - (np.linalg.norm(s2)**2 - np.linalg.norm(s3)**2), (R[3]**2 - R[4]**2) - (np.linalg.norm(s3)**2 - np.linalg.norm(s4)**2)])
  x_hat = np.matmul(np.matmul(np.linalg.inv(np.matmul(A.transpose(),A)),A.transpose()),B)
  error_x = np.linalg.norm(x_hat - np.array([100,100,100,x_hat[3]]))
  error3 = error3 + error_x
  sum = sum + x_hat

print("Average User Position:", sum/10) # first 3 elements are its coordinates
print("Average Error in Position:", error3/10)

# Error in Time = 0.33%
sum = np.array([0,0,0,0])
error4 = 0
for i in range(0,10):
  T_random = np.array([t0+random.randrange(-19,19)/10000, t1+random.randrange(-69,69)/10000, t2+random.randrange(-143,143)/10000, t3+random.randrange(-159,159)/10000, t4+random.randrange(-1924,1924)/10000])
  R = np.multiply(300000, T_random)
  A = np.array([np.append(2*(s1-s0),2*(R[1]-R[0])), np.append(2*(s2-s1),2*(R[2]-R[1])), np.append(2*(s3-s2),2*(R[3]-R[2])), np.append(2*(s4-s3),2*(R[4]-R[3]))])
  B = np.array([(R[0]**2 - R[1]**2) - (np.linalg.norm(s0)**2 - np.linalg.norm(s1)**2), (R[1]**2 - R[2]**2) - (np.linalg.norm(s1)**2 - np.linalg.norm(s2)**2), (R[2]**2 - R[3]**2) - (np.linalg.norm(s2)**2 - np.linalg.norm(s3)**2), (R[3]**2 - R[4]**2) - (np.linalg.norm(s3)**2 - np.linalg.norm(s4)**2)])
  x_hat = np.matmul(np.matmul(np.linalg.inv(np.matmul(A.transpose(),A)),A.transpose()),B)
  error_x = np.linalg.norm(x_hat - np.array([100,100,100,x_hat[3]]))
  error4 = error4 + error_x
  sum = sum + x_hat

print("Average User Position:", sum/10) # first 3 elements are its coordinates
print("Average Error in Position:", error4/10)

# Error in Time = 1%
sum = np.array([0,0,0,0])
error5 = 0
for i in range(0,10):
  T_random = np.array([t0+random.randrange(-58,58)/10000, t1+random.randrange(-206,206)/10000, t2+random.randrange(-428,428)/10000, t3+random.randrange(-476,476)/10000, t4+random.randrange(-5774,5774)/10000])
  R = np.multiply(300000, T_random)
  A = np.array([np.append(2*(s1-s0),2*(R[1]-R[0])), np.append(2*(s2-s1),2*(R[2]-R[1])), np.append(2*(s3-s2),2*(R[3]-R[2])), np.append(2*(s4-s3),2*(R[4]-R[3]))])
  B = np.array([(R[0]**2 - R[1]**2) - (np.linalg.norm(s0)**2 - np.linalg.norm(s1)**2), (R[1]**2 - R[2]**2) - (np.linalg.norm(s1)**2 - np.linalg.norm(s2)**2), (R[2]**2 - R[3]**2) - (np.linalg.norm(s2)**2 - np.linalg.norm(s3)**2), (R[3]**2 - R[4]**2) - (np.linalg.norm(s3)**2 - np.linalg.norm(s4)**2)])
  x_hat = np.matmul(np.matmul(np.linalg.inv(np.matmul(A.transpose(),A)),A.transpose()),B)
  error_x = np.linalg.norm(x_hat - np.array([100,100,100,x_hat[3]]))
  error5 = error5 + error_x
  sum = sum + x_hat

print("Average User Position:", sum/10) # first 3 elements are its coordinates
print("Average Error in Position:", error5/10)

"""Graph: **Amount of timing errors** vs **Localization error**:"""

time_error = [0.0033,0.033,0.1,0.33,1]
localization_error = [error1/10, error2/10, error3/10, error4/10, error5/10]

plt.xlabel('Time Error in %')
plt.ylabel('Localization Error in Km')
plt.scatter(time_error, localization_error), plt.plot(time_error,localization_error)